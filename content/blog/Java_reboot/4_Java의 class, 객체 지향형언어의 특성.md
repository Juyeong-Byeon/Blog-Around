---
title: Java - 자바의 class, 객체 지향형 언어의 특성.
date: "20200420"
description: "Java의 객체 지향적 특성 "
---

# Java의 class, 객체지향형 언어의 특성

객체지향형은 소프트웨어 모듈의 재사용성과 독립성을 지원해준다. 

즉 코드에 객체라는 효율적인 정보관리를 위해 의미를 부여하고, 분류하는 개념적인 단위를 이용한 것이다.또한 객체는 순차 지향형 언어가 공유데이터에 함수로써 접근해 결과를 얻어내는 것과 다르게 (객체.프로퍼티) 꼴의 message를 통해 통신함으로써 원하는 결과를 얻게 된다. 

객체는 메서드와 프로퍼티로 구성되어있으며, 메서드는 객체의 정보인 프로퍼티와 파라미터로 전달되는 값을 이용해 객체가 할 수 있도록 정의된 일들을 해준다. 이러한 객체를 생성해주는 것을 class라고 한다. 클래스는 객체를 생성하는 template로 볼 수 있다. 
클래스는 자료구조(필드)와 연산(메서드)를 가진다. 
클래스로 부터 생성된 객체를 instance라고 부른다. 
class를 이용해 객체를 생성할 땐, 다음과 같이 생성한다. 

```java
classname testC=new classname();
```
이렇게 생성한 객체는 class에서 정의하는 프로퍼티와, 메서드를 가지게 된다. 

## 클래스의 상속

클래스의 상속이란 추상화된 클래스를 하위클래스가 그 특성을 받아 이용하고, 구체화 시키는 것을 말한다. 이로써 하위클래스가 꼭 가져야 하는 메서드와, 프로퍼티를 강제할 수도 있고, 소프트웨어의 재사용성을 지원할 수 있다.

예를 들어 학생에는 초등학생, 중학생, 고등학생, 대학생이 있다. 이 객체들에서 학생이 공통적으로 가지는 특성은 학교 이름과 학년이 있을 것이다. 또한 학생이 가지는 기본적인 행위인 수강, 시험보기 등의 기능이 공통적으로 있을 것이다. 이 것을 가지는 상위 클래스인 학생을 정의하고, 상속 함으로써 각각 초등학생, 중학생, 고등학생, 대학생의 class를 정의 할 때, 공통적인 기능과 프로퍼티는 새로 정의 하지 않아도 되는 것이다. 


## 캡슐화 
객체를 캡슐화 해서 어떠한 작업을 할 수 있는 인터페이스와, 제공하는 정보만을 볼 수 있게 하고, 이외의 프로퍼티는 객체 내부에서만 접근 할 수 있도록 하여 해당 객체를 이용할때, 용도와 다르게 이용되거나, 처리가 되는 과정이 드러나는 것을 막는다. 

이 방법을 통해 독립성과, 사용법의 지속성, 이식성등을 좋게 할 수 있다. 

## 다형성 (polymorphism)

하나의 인터페이스를 사용해 다양한 구현 방법을 제공 하는 것이다. 상위클래스변수를 선언한 후 runtime에 상황에 맞게 하위 class를 이용해 초기화 해주는 것을 의미한다. 이로써 객체를 이용할 때, 더 다양한 구현체를 다룰 수 있도록 지윈한다. 

## Class의 선언 및 정의 
```java
[클래스 접근 제한자,private,public,protected] class className [extends superclass] [implements interfaceName] {
    [필드 접근 제한자] 멤버변수;
    [생성자 접근 제한자] [생성자];
    [메소드 접근 제한자] 메서드
}
//[]안의 값은 옵션이라는 뜻이다.
```
이를 기반으로 class를 정의 해보자면
```java
public class Student{
    private String name;
    private int age;
    private int grade;
    public static int counter;

    public Student(String name, int age, int grade){
        this.name=name;
        this.age=age;
        this.grade=grade;
    }
    public void attend(){
        System.out.printf("hi my name is %s ",this.name);
    }
}
```
와 같이 정의 할 수 있다. 

만약 이 class를 사용하고 싶다면 정의와 생성을 해주어야 한다. 

정의
```java
Student student1;
//className objName= new className();
```
와 같이 정의 할 수 있다. 

이렇게 정의 했을때는 아직 student 변수에 메모리 공간이 할당되지 않았다. 따라서 다음과 같이 생성을 해주어야 한다. 

```java
student1=new Student("drone",20,4)//생성자를 이용한 프로퍼티 초기화
```
객체 내의 속성을 참조하고 싶을 때는 
```java
student1.name
```
와 같이 참조하면 된다 하지만 위의 예제에서는 private를 이용해 객체 내부에서만 참조 가능하도록 객체를 캡슐화 시켜 놓았기 때문에 

```java
student1.attend();
```
와 같이 getter함수나, 내부에 정의된 함수를 이용해 참조 해야한다. 

### java는 메모리를 자동으로 관리해주기 때문에 객체의 소멸자를 지원하지 않는다. 

## 맴버변수 

맴버변수는 클래스 선언시에 클래스 내에 메소드와 함께 메소드 바깥부분에 선언되는 객체의 고유한 정보를 저장하는 변수이다.

맴버변수의 종류에는
1. 객체변수
    
    객체의 속성을 표현하기 위해 기본자료형 변수들로 선언된다. 
    기본적인 값들이 저장된다. 
    객체 참조변수의 경우 객체가 저장된 메모리의 주소가 저장된다.

2. 클래스변수
    
    클래스의 모든 객체가 공유할 수 있는 변수이다. 
    한정자 앞에 static을 선언한다.
    class를 정의 할 때 static을 이용해 변수를 정의해 놓을 경우 class를 이용해 만든 객체인 인스턴스들이 해당 static 변수를 공유한다.

3. 종단변수
    
    상수값을 정의하는 변수이다.
    한번 선언되어 초기화 되면 그 값을 변경할 수 없게된다. 
    ```java
    final float PI=3.141592;
    ```

## 메소드 

메소드는 객체가 할 수 있는 행동을 하도록 하는 명령이다. 
또한 객체를 외부에서 사용할 수 있도록 연결해주는 인터페이스이다.

매소드는 
```java
[접근제어자] returnType methodName(argument){

    return something
}
```
와 같은 방식으로 정의가 된다. 

argument는 실인수와 가인수로 나뉘는데,
actual argument 는 호출 메서드에 나타나는 인수이고(body에서 사용되는 메모리)
formal argument는 피호출 메소드에 나타나는 인수이다. 

메소드의 종류는
1. 객체 메소드
    
    객체를 통해 접근 가능한 메소드
2. 클래스 메소드

    클래스의 모든 객체가 공유할 수 있는 메서드

3. 종단 메소드

    서브클레스에서 오버라이딩(overriding)될 수 없는 메소드
4. 추상 메소드

    추상 클래스 안에서만 선언 가능하며, 선언부분만 가지고 있으며, 몸체는 가질 수 없다. 인터페이스 제공

6. 동기 메소드 
    스레드를 동기화 가능한 기법을 제공하는 메소드 

등이 있다. 


## 메소드의 overloading

같은 class내에서 이름이 같은 다른 타입의 메소드가 존재하는 것을 말한다. 오버로딩된 메서드는 각각을 구분하기 위해 매개변수의 데이터형, 또는 개수가 반드시 달라야 한다. 

static으로 정의된 정적 메서드는 오버로딩 불가

메소드의 오버로딩은 객체 지향형에서 다형성 개념을 지원해준다.

## 생성자 

클래스에서 객체를 생성할 때, 객체를 초기화 하는 특수한 메소드이다. 
클래스명과 동일한 이름을 사용하며, 사용후 반환 값이 없다.

class내의 객체 변수들을 초기화 할 때, 사용한다. 명시적으로 생성자를 호출 하지 않고, new연산자를 이용해 객체가 생성될 때, 자동적으로 호출 된다. 


