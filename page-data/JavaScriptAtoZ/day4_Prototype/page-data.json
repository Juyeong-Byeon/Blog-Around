{"componentChunkName":"component---src-templates-blog-post-js","path":"/JavaScriptAtoZ/day4_Prototype/","result":{"data":{"site":{"siteMetadata":{"title":"Blog-Around"}},"markdownRemark":{"id":"cba9a372-1e15-5510-b6df-e1bdb3b66de4","excerpt":"Prototype 이 정리는 프로토타입 이해하기,MDN Object prototypes 를 참고해 작성한 글입니다.  자바스크립트를 처음 배우기 시작할 때 JS는 객체 지향형 언어의 패러다임의 특성을 가지고 있다는 말을 들었을 것이다. ES6 에서 class 가 추가되긴 하였지만 js…","html":"<h1>Prototype</h1>\n<p>이 정리는 <a href=\"https://medium.com/@bluesh55/javascript-prototype-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-f8e67c286b67\">프로토타입 이해하기</a>,<a href=\"https://developer.mozilla.org/ko/docs/Learn/JavaScript/Objects/Object_prototypes\">MDN Object prototypes</a> 를 참고해 작성한 글입니다. </p>\n<p>자바스크립트를 처음 배우기 시작할 때 JS는 객체 지향형 언어의 패러다임의 특성을 가지고 있다는 말을 들었을 것이다. ES6 에서 class 가 추가되긴 하였지만 js의 상속은 다른 언어의 상속과는 다르다. 이는 JS가 프로토 타입 상속을 하기 때문인데 Prototype이 뭔지 정리해보자. </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>ear<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>nose<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>mouth<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> person1<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> person2<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nperson1<span class=\"token punctuation\">.</span>ear<span class=\"token punctuation\">;</span><span class=\"token comment\">//2</span></code></pre></div>\n<p>이렇게 될 경우 person1과 person2에 각각의 ear, nose, mouth 등이 각각 생성되어 메모리를 차지 한다. 만약 수 많은 객체가 생성되면 메모리의 낭비가 심해질 것이다. 이러한 문제를 해결하고, 여러 메서드, 오브젝트들을 공유하기 위해 사용하는 것이 바로 Prototype 상속이다.</p>\n<p>prototype은 하나의 원형이 되는 함수에서 생성되는 모든 함수들이 공유하는 값, 객체들이 들어있는 object인데, 같은 공유되는 ref를 참조한다.</p>\n<p>prototype 으로 상속을 할 경우 다음과 같이 하면 되는데</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token class-name\">Person</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"이름\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> person1<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> person2<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nperson1<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">;</span><span class=\"token comment\">//\"이름\"</span>\nperson2<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">;</span><span class=\"token comment\">//\"이름\"</span></code></pre></div>\n<p>이럴 경우 Person object내의 prototype object에 대한 ref가 공유되기 때문에 같은 값을 가지게 된다. </p>\n<p>이 것에 대해 조금 더 차근차근 알아보자</p>\n<h2>함수 생성과정</h2>\n<h3>1. prototype Object</h3>\n<p>js 에서 객체는 항상 함수로 생성된다. </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> arr<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 사실 let arr=new Array();</span>\n<span class=\"token keyword\">let</span> obj<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 사실 let obj=new Object();</span>\n<span class=\"token keyword\">let</span> a<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//let a=new Number(1)</span></code></pre></div>\n<p>위의 예에서 알 수 있듯이 우리가 사용하는 객체는 항상 함수를 통해 생성됨을 알 수 있다. </p>\n<p>함수를 처음에 정의하면 constructor 라는 자격을 부여해 정의된 함수로 새로운 객체를 만들어낼 수 있는 자격을 준다. </p>\n<p>object.constructor 를 이용하면 해당 객체가 어떠한 생성자를 통해 만들어졌는지 확인 할 수 있다. </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\nfoo<span class=\"token punctuation\">.</span>constructor<span class=\"token comment\">//Function() { [native code] }new Function()을 통해 생성되었음을 알 수 있다. </span>\n<span class=\"token keyword\">let</span> foo2<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nfoo2<span class=\"token punctuation\">.</span>constructor<span class=\"token comment\">//foo(){} 함수를 통해 만들어졌음</span></code></pre></div>\n<h3>2. prototype object 생성, 연결</h3>\n<p>이렇게 constructor로서의 자격을 얻은 함수는 새로 생성된 prototype 객체와 연결이 된다. 이 객체는 상속이 될 때, 하위객체에서 접근 가능하며, 접근하여 값을 읽어올 수 있는 공유된 객체이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\nfoo<span class=\"token punctuation\">.</span>prototype\n<span class=\"token comment\">/*\nfoo.prototype.age=10\n10\nfoo.prototype\n{age: 10, constructor: ƒ}//prototype\n*/</span>\n\n<span class=\"token keyword\">let</span> foo2<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nfoo2<span class=\"token punctuation\">.</span>age\n<span class=\"token comment\">//10</span>\nfoo2<span class=\"token punctuation\">.</span>__proto__\n<span class=\"token comment\">//{age: 10, constructor: ƒ}//공유되는 prototype</span></code></pre></div>\n<p>여기서 한가지 더 볼 점은 <strong>proto</strong>는 자신이 상속 받은 객체의 prototype object이다. 위의 참조가 가능하게 하는 이유는 이 객체 때문이다.\njs에서 객체 내에 선언되어있는 객체가 존재 하지 않으면 <strong>proto</strong>를 타고 올라가 상위에서 찾아내고, 최 상위인 object에도 없으면 에러를 일으킨다 이것을 prototype link라고 한다. </p>\n<p>예를 들어 이를 통해 Array가 Object의 메서드 들을 상속 받았음을 증명할 수 있다. t</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> arr<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\narr<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">;</span><span class=\"token comment\">//arr의 __proto__는 Array정의시에 생성된 Array.prototype()</span>\n<span class=\"token comment\">/*Array에서 지원하는 많은 메서드들\nconcat: ƒ concat()\nconstructor: ƒ Array()\ncopyWithin: ƒ copyWithin()\nentries: ƒ entries()\n...\n..\n.\n\n__proto__: Object //이 를 보면 Array의 prototype 또한 Object로 부터 상속받아 생성되었음을 알 수 있다. \n*/</span></code></pre></div>","frontmatter":{"title":"JS - 프로토타입","date":"July 06, 2020","description":"JS의 프로토타입 상속"}}},"pageContext":{"slug":"/JavaScriptAtoZ/day4_Prototype/","previous":{"fields":{"slug":"/YDKJS_study/day2_Value/"},"frontmatter":{"title":"JS - Value"}},"next":{"fields":{"slug":"/git/git-flow/git-flow/"},"frontmatter":{"title":"git의 효율적인 관리 전략 Git-flow."}}}},"staticQueryHashes":["2841359383","916993862"]}